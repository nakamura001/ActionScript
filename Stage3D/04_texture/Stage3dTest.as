// 【参考サイト】// http://www.adobe.com/devnet/flashplayer/articles/perspective-projection.htmlpackage  {	import com.adobe.utils.*;		import flash.display.*;	import flash.display3D.*;	import flash.display3D.textures.*;	import flash.events.Event;	import flash.geom.*;	import flash.utils.*;	[SWF(width="640", height="480", frameRate="60", backgroundColor="#FFFFFF")]	public class Stage3dTest extends Sprite {		private const swfWidth:int = 640;		private const swfHeight:int = 480;		private const textureSize:int = 128;				// 3D空間用のコンテキスト		private var context3D:Context3D;		// コンパイル済みのシェーダプログラム		private var shaderProgram:Program3D;		// 頂点バッファ		private var vertexBuffer:VertexBuffer3D;		// インデックスバッファ				private var indexBuffer:IndexBuffer3D;		private var meshVertexData:Vector.<Number>;		private var meshIndexData:Vector.<uint>;		private var projectionMatrix:PerspectiveMatrix3D =			new PerspectiveMatrix3D();		private var modelMatrix:Matrix3D = new Matrix3D();		private var viewMatrix:Matrix3D = new Matrix3D();		private var modelViewProjection:Matrix3D = new Matrix3D();				private var t:Number = 0;				private var myBitmapDataObject:myTextureBitmapData = 			new myTextureBitmapData(textureSize, textureSize);		private var myTextureData:Bitmap = new Bitmap(myBitmapDataObject);									private var myTexture:Texture;		public function Stage3dTest() {			if (stage != null)				init();			else				addEventListener(Event.ADDED_TO_STAGE, init);		}				private function init(e:Event = null) :void{			if (hasEventListener(Event.ADDED_TO_STAGE))				removeEventListener(Event.ADDED_TO_STAGE, init);						stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;						stage.stage3Ds[0].addEventListener(				Event.CONTEXT3D_CREATE, onContext3DCreate);			stage.stage3Ds[0].requestContext3D();		}				private function onContext3DCreate(event:Event):void		{			removeEventListener(Event.ENTER_FRAME, enterFrame);						var t:Stage3D = event.target as Stage3D;			context3D = t.context3D;						if (context3D == null) {				return;			}						context3D.enableErrorChecking = true;						initData();						context3D.configureBackBuffer(swfWidth, swfHeight, 0, true);						var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();			vertexShaderAssembler.assemble			(			 	Context3DProgramType.VERTEX,				"m44 op, va0, vc0\n" +				"mov v0, va1\n"			);						var fragmentShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();			fragmentShaderAssembler.assemble			(				Context3DProgramType.FRAGMENT,				"tex ft1, v0, fs0 <2d,linear,nomip>\n" +				"mov oc, ft1"			);						shaderProgram = context3D.createProgram();			shaderProgram.upload(vertexShaderAssembler.agalcode,				fragmentShaderAssembler.agalcode);						indexBuffer = context3D.createIndexBuffer(meshIndexData.length);			indexBuffer.uploadFromVector(meshIndexData, 0, meshIndexData.length);						vertexBuffer = context3D.createVertexBuffer(				meshVertexData.length/5, 5);			vertexBuffer.uploadFromVector(meshVertexData, 				0, meshVertexData.length/5);									myTexture = context3D.createTexture(textureSize, textureSize, 				Context3DTextureFormat.BGRA, false);			myTexture.uploadFromBitmapData(myTextureData.bitmapData);			projectionMatrix.identity();			projectionMatrix.perspectiveFieldOfViewRH(				45.0, swfWidth / swfHeight, 0.01, 100.0);						viewMatrix.identity();			viewMatrix.appendTranslation(0, 0, -4);						addEventListener(Event.ENTER_FRAME, enterFrame);		}		private function enterFrame(e:Event):void{			context3D.clear(0,0,0);			context3D.setProgram(shaderProgram);						modelMatrix.identity();						// Y軸を中心に回転			modelMatrix.appendRotation(t*0.5, Vector3D.Y_AXIS);			t += 2.0;						modelViewProjection.identity();			modelViewProjection.append(modelMatrix);			modelViewProjection.append(viewMatrix);			modelViewProjection.append(projectionMatrix);						// シェーダ上では vc0			context3D.setProgramConstantsFromMatrix(				Context3DProgramType.VERTEX,				0, modelViewProjection, true);						// 頂点情報の位置を指定(シェーダ上では va0)			context3D.setVertexBufferAt(0, vertexBuffer, 0,				Context3DVertexBufferFormat.FLOAT_3);			// UV座標情報の位置を指定(シェーダ上では va1)			context3D.setVertexBufferAt(1, vertexBuffer, 3,				Context3DVertexBufferFormat.FLOAT_2);			// テクスチャを指定(シェーダ上では fs0)			context3D.setTextureAt(0, myTexture);			context3D.drawTriangles(indexBuffer, 0, meshIndexData.length/3);			context3D.present();					}				private function initData():void{			meshIndexData = Vector.<uint>				([					0, 1, 2,					2, 3, 0					]);						meshVertexData = Vector.<Number>				([					-1, -1, 0,  0, 1, // x, y, z, u, v					-1,  1, 0,  0, 0, 					 1,  1, 0,  1, 0,					 1, -1, 0,  1, 1					]);		}	}	}